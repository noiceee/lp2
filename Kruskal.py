# -*- coding: utf-8 -*-
"""AI-6(Kruskal).ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1yTZqCYk51TgG-LNXwEo8jFOC9fMCt2YM
"""

# Class to represent a graph
class Graph:
    def __init__(self, vertices):
        self.V = vertices
        self.graph = []

    # Function to add an edge to the graph
    def add_edge(self, src, dest, weight):
        self.graph.append([src, dest, weight])

    # Function to find the parent of a vertex
    def find_parent(self, parent, i):
        if parent[i] == i:
            return i
        return self.find_parent(parent, parent[i])

    # Function to perform union of two subsets
    def union(self, parent, rank, x, y):
        root_x = self.find_parent(parent, x)
        root_y = self.find_parent(parent, y)
        if rank[root_x] < rank[root_y]:
            parent[root_x] = root_y
        elif rank[root_x] > rank[root_y]:
            parent[root_y] = root_x
        else:
            parent[root_y] = root_x
            rank[root_x] += 1

    # Function to perform Kruskal's algorithm
    def kruskal_mst(self):
        result = []  # Stores the minimal spanning tree
        i = 0  # Index variable for sorted edges
        e = 0  # Index variable for result[]

        # Sort all the edges in non-decreasing order of their weight
        self.graph = sorted(self.graph, key=lambda item: item[2])

        parent = []
        rank = []

        # Create subsets with single elements
        for node in range(self.V):
            parent.append(node)
            rank.append(0)

        while e < self.V - 1:
            # Pick the smallest edge and increment the index for the next iteration
            src, dest, weight = self.graph[i]
            i += 1

            root_src = self.find_parent(parent, src)
            root_dest = self.find_parent(parent, dest)

            # Check if including the current edge causes a cycle or not
            if root_src != root_dest:
                e += 1
                result.append([src, dest, weight])
                self.union(parent, rank, root_src, root_dest)

        # Print the minimal spanning tree
        print("Minimal Spanning Tree:")
        for src, dest, weight in result:
            print(f"{src} -- {dest} \tWeight: {weight}")


# Take input from the user
vertices = int(input("Enter the number of vertices: "))
edges = int(input("Enter the number of edges: "))

# Create a graph object
graph = Graph(vertices)

# Input the edges and their weights
for i in range(edges):
    src, dest, weight = map(int, input("Enter source, destination, and weight of edge separated by spaces: ").split())
    graph.add_edge(src, dest, weight)

# Find and print the minimal spanning tree using Kruskal's algorithm
graph.kruskal_mst()



'''
Kruskal's algorithm is a greedy algorithm used to find the Minimum Spanning Tree (MST) of a connected, weighted graph. The MST is a subset of edges that connects all vertices of the graph with the minimum total weight.

Here's a step-by-step explanation of Kruskal's algorithm:

1. Sort all the edges of the graph in non-decreasing order of their weights.

2. Create an empty set to store the MST.

3. Iterate through the sorted edges. For each edge, do the following:
   - If including the edge does not create a cycle in the MST, add the edge to the MST set.
   - Otherwise, discard the edge.

To check if including an edge creates a cycle, the algorithm uses a disjoint set data structure. The disjoint set data structure keeps track of the connected components of the graph and allows efficient operations to check if two vertices belong to the same component and to merge components.

4. Continue the iteration until all edges have been considered or the MST set contains `V - 1` edges, where `V` is the number of vertices in the graph. The MST will have `V - 1` edges for a connected graph with `V` vertices.

5. The MST set obtained at the end of the algorithm represents the Minimum Spanning Tree of the graph.

Kruskal's algorithm guarantees that the MST is constructed by adding edges in non-decreasing order of their weights, while ensuring that no cycles are formed in the process. By considering edges in this manner, the algorithm progressively connects the vertices with the minimum weight edges until all vertices are included in the MST.

Kruskal's algorithm has a time complexity of O(E log E), where E is the number of edges in the graph, due to the sorting step.

------------------

This code implements Kruskal's algorithm to find the Minimum Spanning Tree (MST) of a graph. Let's go through the code step by step:

1. The `Graph` class is defined with an `__init__` method that initializes the number of vertices (`self.V`) and an empty list to store the graph's edges (`self.graph`).

2. The `add_edge` method is used to add an edge to the graph. It takes the source vertex, destination vertex, and weight of the edge as parameters and appends the edge to the `self.graph` list.

3. The `find_parent` method is a utility function that implements the Find operation of the disjoint set data structure. It recursively finds the parent of a vertex `i` until it reaches the root parent.

4. The `union` method is a utility function that implements the Union operation of the disjoint set data structure. It performs the union of two subsets by considering the rank (or depth) of each subset. It ensures that the smaller rank subset is appended to the larger rank subset.

5. The `kruskal_mst` method performs Kruskal's algorithm to find the MST of the graph. It uses a sorting step to sort the edges of the graph in non-decreasing order of their weights.

6. It initializes variables `result`, `i`, and `e`. `result` will store the edges of the MST, `i` is an index variable for the sorted edges, and `e` is an index variable for the `result` list.

7. The `self.graph` list is sorted using a lambda function as the sorting key, which sorts the edges based on their weights.

8. Two empty lists, `parent` and `rank`, are created to store the parent and rank information for each vertex. Each vertex initially forms its own subset, so the parent is set to itself, and the rank is set to 0.

9. The algorithm iterates over the sorted edges until `e` reaches `self.V - 1` (the number of vertices minus 1). It picks the smallest edge, checks if including it creates a cycle (by comparing the root parents of the source and destination vertices), and if not, adds it to the `result` list.

10. The `union` method is called to merge the subsets of the source and destination vertices.

11. Finally, the `result` list contains the edges of the MST, which is printed as the minimal spanning tree, showing the source vertex, destination vertex, and weight of each edge.

The user is prompted to input the number of vertices and edges of the graph, followed by the source vertex, destination vertex, and weight for each edge.

The code then creates a `Graph` object, adds the edges to the graph, and calls the `kruskal_mst` method to find and print the minimal spanning tree using Kruskal's algorithm.

'''