# -*- coding: utf-8 -*-
"""AI-7(graph_colouring).ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1n828ynFGsBgbjUv2dqa_oobmLLK47xDS

This code is an implementation of the graph coloring problem. Given a graph represented as an adjacency list and a number of colors, the goal is to assign colors to each vertex in such a way that no two adjacent vertices have the same color.

The `graph_coloring` function takes two arguments: `graph` and `num_colors`. `graph` is a dictionary where each key represents a vertex, and its corresponding value is a list of its neighboring vertices. `num_colors` is the total number of colors available for coloring the vertices.

The function uses a backtracking algorithm to explore different color assignments for each vertex until a valid solution is found or all possibilities have been exhausted. It starts with the first vertex (vertex 0) and recursively tries different colors for that vertex. It checks if assigning a color to the current vertex is safe by ensuring that none of its neighbors have the same color. If a safe color is found, it assigns the color to the vertex and recursively calls the function for the next vertex. If a solution is found, it prints the color assignment for each vertex. If no solution is found after trying all possible color assignments, it prints a message indicating that no solution was found.

The code prompts the user to enter the number of vertices in the graph and then iteratively collects the adjacency list for each vertex. It also prompts for the number of colors to be used. Finally, it calls the `graph_coloring` function with the provided graph and number of colors.

In summary, this code demonstrates an implementation of the graph coloring problem using a backtracking algorithm to find a valid color assignment for the given graph.

"""

def graph_coloring(graph, num_colors):
    # Create a list to store the color assigned to each vertex
    colors = [0] * len(graph)

    def is_safe(vertex, color):
        # Check if it is safe to color the vertex with the given color
        for neighbor in graph[vertex]:
            if colors[neighbor] == color:
                return False
        return True

    def backtrack(vertex):
        # Base case: All vertices have been assigned colors
        if vertex == len(graph):
            return True

        # Try all possible colors for the current vertex
        for color in range(1, num_colors + 1):
            if is_safe(vertex, color):
                # Assign the color to the vertex
                colors[vertex] = color

                # Recursively backtrack to assign colors to the remaining vertices
                if backtrack(vertex + 1):
                    return True

                # If the current configuration doesn't lead to a solution, backtrack
                colors[vertex] = 0

        return False

    # Start with the first vertex (vertex index 0)
    if backtrack(0):
        # If a solution is found, print the color assignment
        print("Color assignment:")
        for vertex, color in enumerate(colors):
            print(f"Vertex {vertex}: Color {color}")
    else:
        print("No solution found.")

# Gather the graph information from the user
num_vertices = int(input("Enter the number of vertices: "))

graph = {}
for vertex in range(num_vertices):
    neighbors = input(f"Enter the neighbors of vertex {vertex} (separated by spaces): ").split()
    graph[vertex] = [int(neighbor) for neighbor in neighbors]

# Prompt the user to enter the number of colors
num_colors = int(input("Enter the number of colors: "))

# Call the graph_coloring function
graph_coloring(graph, num_colors)